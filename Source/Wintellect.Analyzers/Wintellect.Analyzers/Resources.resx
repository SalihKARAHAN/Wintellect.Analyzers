<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AssembliesHaveCompanyAttributeAnalyzerDescription" xml:space="preserve">
    <value>Specifying the AssemblyCompanyAttribute identifies the company that produced the assembly</value>
  </data>
  <data name="AssembliesHaveCompanyAttributeAnalyzerMessageFormat" xml:space="preserve">
    <value>Add a filled out AssemblyCompanyAttribute to the assembly properties</value>
  </data>
  <data name="AssembliesHaveCompanyAttributeAnalyzerTitle" xml:space="preserve">
    <value>Assemblies need the AssemblyCompanyAttribute</value>
  </data>
  <data name="AssembliesHaveCopyrightAttributeAnalyzerDescription" xml:space="preserve">
    <value>Specifying the AssemblyCopyrightAttribute sets who owns the copyright to the assembly</value>
  </data>
  <data name="AssembliesHaveCopyrightAttributeAnalyzerMessageFormat" xml:space="preserve">
    <value>Add a filled out AssemblyCopyrightAttribute to the assembly properties</value>
  </data>
  <data name="AssembliesHaveCopyrightAttributeAnalyzerTitle" xml:space="preserve">
    <value>Assemblies need the AssemblyCopyrightAttribute</value>
  </data>
  <data name="AssembliesHaveDescriptionAttributeAnalyzerDescription" xml:space="preserve">
    <value>Specifying the AssemblyDescriptionAttribute declares the purpose of the assembly</value>
  </data>
  <data name="AssembliesHaveDescriptionAttributeAnalyzerMessageFormat" xml:space="preserve">
    <value>Add a filled out AssemblyDescriptionAttribute to the assembly properties</value>
  </data>
  <data name="AssembliesHaveDescriptionAttributeAnalyzerTitle" xml:space="preserve">
    <value>Assemblies need the AssemblyDescriptionAttribute</value>
  </data>
  <data name="AssembliesHaveTitleAttributeAnalyzerDescription" xml:space="preserve">
    <value>Specifying the AssemblyTitleAttribute helps identify the assembly</value>
  </data>
  <data name="AssembliesHaveTitleAttributeAnalyzerMessageFormat" xml:space="preserve">
    <value>Add a filled out AssemblyTitleAttribute to the assembly properties</value>
  </data>
  <data name="AssembliesHaveTitleAttributeAnalyzerTitle" xml:space="preserve">
    <value>Assemblies need the AssemblyTitleDescriptionAttribute</value>
  </data>
  <data name="AvoidCallingMethodsWithParamArgsInLoopsAnalyzerDescription" xml:space="preserve">
    <value>Methods with variable length arguments (param array) can lead to performance problems inside loops</value>
  </data>
  <data name="AvoidCallingMethodsWithParamArgsInLoopsAnalyzerMessageFormat" xml:space="preserve">
    <value>Call to a method using a param array as arguments '{0}' in a loop</value>
  </data>
  <data name="AvoidCallingMethodsWithParamArgsInLoopsAnalyzerTitle" xml:space="preserve">
    <value>Avoid calling methods with param array arguments in loops</value>
  </data>
  <data name="AvoidPreDefinedTypesAnalyzerDescription" xml:space="preserve">
    <value>Being explicit about your types is better according to CLR via C# by Jeffrey Richter</value>
  </data>
  <data name="AvoidPreDefinedTypesAnalyzerMessageFormat" xml:space="preserve">
    <value>Convert '{0}' to the explicit type '{1}'</value>
  </data>
  <data name="AvoidPreDefinedTypesAnalyzerTitle" xml:space="preserve">
    <value>Use explicit types instead of predefined to avoid confusion</value>
  </data>
  <data name="CallAssertMethodsWithMessageParameterAnalyzerDescription" xml:space="preserve">
    <value>Always use the multiple parameter version of Debug.Assert for better error reporting</value>
  </data>
  <data name="CallAssertMethodsWithMessageParameterAnalyzerMessageFormat" xml:space="preserve">
    <value>Never use the single parameter Debug.Assert</value>
  </data>
  <data name="CallAssertMethodsWithMessageParameterAnalyzerTitle" xml:space="preserve">
    <value>Always use Debug.Assert methods that have a message parameter</value>
  </data>
  <data name="CategoryDesign" xml:space="preserve">
    <value>Design</value>
  </data>
  <data name="CategoryDocumentation" xml:space="preserve">
    <value>Documentation</value>
  </data>
  <data name="CategoryFormatting" xml:space="preserve">
    <value>Formatting</value>
  </data>
  <data name="CategoryPerformance" xml:space="preserve">
    <value>Performance</value>
  </data>
  <data name="CategoryUsage" xml:space="preserve">
    <value>Usage</value>
  </data>
  <data name="ClassesShouldBeSealedAnalyzerDescription" xml:space="preserve">
    <value>When writing new classes, they should be declared as sealed</value>
  </data>
  <data name="ClassesShouldBeSealedAnalyzerMessageFormat" xml:space="preserve">
    <value>The class '{0}' should be declared sealed if this is a newly written class</value>
  </data>
  <data name="ClassesShouldBeSealedAnalyzerTitle" xml:space="preserve">
    <value>New classes should be declared as sealed</value>
  </data>
  <data name="ClassesShouldBeSealedCodeFixActionText" xml:space="preserve">
    <value>Make sealed</value>
  </data>
  <data name="ExceptionDocumentationMissingAnalyzerActionMessage" xml:space="preserve">
    <value>Document this direct throw</value>
  </data>
  <data name="ExceptionDocumentationMissingAnalyzerDescription" xml:space="preserve">
    <value>Alll direct throws must always be documented with &lt;exception&gt; tags</value>
  </data>
  <data name="ExceptionDocumentationMissingAnalyzerMessageFormat" xml:space="preserve">
    <value>Document the direct throw of type '{0}' with an &lt;exception&gt; tag</value>
  </data>
  <data name="ExceptionDocumentationMissingAnalyzerTitle" xml:space="preserve">
    <value>All direct throws must be documented with &lt;exception&gt; tags</value>
  </data>
  <data name="IfAndElseMustHaveBracesAnalyzerDescription" xml:space="preserve">
    <value>If and else statements must use braces even for single line results</value>
  </data>
  <data name="IfAndElseMustHaveBracesAnalyzerMessageFormat" xml:space="preserve">
    <value>'{0}' statements must have braces</value>
  </data>
  <data name="IfAndElseMustHaveBracesAnalyzerTitle" xml:space="preserve">
    <value>If and else statements must use braces</value>
  </data>
  <data name="IfAndElseMustHaveBracesCodeFixProviderActionMessage" xml:space="preserve">
    <value>Enclose statement in braces</value>
  </data>
  <data name="PendingText" xml:space="preserve">
    <value>&lt;Pending&gt;</value>
  </data>
  <data name="ReturningTaskRequiresAsyncAnalyzerDescription" xml:space="preserve">
    <value>Methods returning Tasks must end in "Task" to indicate they are asynchronous</value>
  </data>
  <data name="ReturningTaskRequiresAsyncAnalyzerMessageFormat" xml:space="preserve">
    <value>Method name {0} should be renamed {0}Async</value>
  </data>
  <data name="ReturningTaskRequiresAsyncAnalyzerTitle" xml:space="preserve">
    <value>All Task or Task&lt;T&gt; returning method names must end with Async</value>
  </data>
  <data name="SuppressionMessageMissingJustificationAnalyzerDescription" xml:space="preserve">
    <value>You must always specify the Justification parameter with the SuppressionMessage attribute</value>
  </data>
  <data name="SuppressionMessageMissingJustificationAnalyzerMessageFormat" xml:space="preserve">
    <value>The SuppressionMessage on '{0}' needs the Justification parameter filled out</value>
  </data>
  <data name="SuppressionMessageMissingJustificationAnalyzerTitle" xml:space="preserve">
    <value>SuppressionMessageAttribute needs to specify the Justification parameter</value>
  </data>
</root>